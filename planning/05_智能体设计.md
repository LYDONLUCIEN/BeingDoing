# 智能体设计

## 一、智能体架构（基于LangGraph）

### 1.1 整体架构（LangGraph状态图）

```
用户输入
   │
   ▼
┌─────────────────┐
│  输入处理节点     │  (解析、分类、上下文提取)
└─────────────────┘
   │
   ▼
┌─────────────────┐
│  推理节点(Thought)│  (ReAct: 思考下一步行动)
└─────────────────┘
   │
   ▼
┌─────────────────┐
│  决策节点        │  (判断需要调用哪个工具/技能)
└─────────────────┘
   │
   ├─── 概念解释工具 ────┐
   ├─── 问题引导工具 ────┤
   ├─── 示例推荐工具 ────┤
   ├─── 内容检索工具 ────┤
   └─── 主动引导工具 ────┘
   │
   ▼
┌─────────────────┐
│  行动节点(Action)│  (执行工具调用)
└─────────────────┘
   │
   ▼
┌─────────────────┐
│  观察节点(Observe)│  (获取工具结果)
└─────────────────┘
   │
   ▼
┌─────────────────┐
│  判断节点        │  (是否需要继续推理？)
└─────────────────┘
   │
   ├─── 是 → 回到推理节点
   └─── 否 → 输出格式化
   │
   ▼
┌─────────────────┐
│  输出格式化节点   │  (结构化输出)
└─────────────────┘
   │
   ▼
用户输出
```

### 1.2 ReAct范式

**ReAct = Reasoning (推理) + Acting (行动)**

**循环流程**：
1. **Thought (思考)**：分析当前状态，决定下一步行动
2. **Action (行动)**：调用工具执行操作
3. **Observation (观察)**：获取工具执行结果
4. **Thought (思考)**：基于观察结果继续推理
5. 重复直到得出最终答案

**示例**：
```
Thought: 用户询问"什么是价值观？"，我需要解释这个概念，并检索相关知识。
Action: search_knowledge(query="价值观", category="values")
Observation: 找到相关价值观定义：价值观是决定生活方式的重要因素...
Thought: 我已经获得了足够的信息，可以给用户一个精炼的回答。
Action: generate_response(context=..., max_length=200)
Observation: 生成回答："价值观是你认为重要的事，它决定了你的生活方式和工作目的..."
```

### 1.3 LangGraph状态图设计

**状态定义**：
```python
from typing import TypedDict, List, Dict, Optional
from langchain_core.messages import BaseMessage

class AgentState(TypedDict):
    """智能体状态"""
    messages: List[BaseMessage]  # 对话消息
    context: Dict  # 上下文信息
    current_step: str  # 当前探索步骤
    current_question_id: Optional[int]  # 当前问题ID
    tools_used: List[str]  # 已使用的工具列表
    reasoning: List[str]  # 推理过程
    final_answer: Optional[str]  # 最终答案
    iteration_count: int  # 迭代次数（防止无限循环）
```

**节点定义**：
- `input_node`: 输入处理节点
- `reasoning_node`: 推理节点（ReAct的Thought）
- `action_node`: 行动节点（ReAct的Action）
- `observation_node`: 观察节点（ReAct的Observation）
- `format_node`: 输出格式化节点

**边定义**：
- `input_node` → `reasoning_node`
- `reasoning_node` → `action_node`
- `action_node` → `observation_node`
- `observation_node` → `should_continue` (条件边)
  - 继续 → `reasoning_node`
  - 完成 → `format_node`

### 1.4 核心模块（LangGraph节点）

#### 1.4.1 输入处理节点 (input_node)
- **功能**：解析用户输入，提取意图和上下文
- **输入**：用户消息、当前步骤、问题ID、选中文本
- **输出**：更新AgentState的messages和context

#### 1.4.2 推理节点 (reasoning_node)
- **功能**：ReAct的Thought阶段，分析当前状态，决定下一步行动
- **实现**：调用LLM进行推理
- **输出**：更新AgentState的reasoning和下一步action

#### 1.4.3 行动节点 (action_node)
- **功能**：ReAct的Action阶段，执行工具调用
- **工具类型**：
  - 概念解释工具
  - 问题引导工具
  - 示例推荐工具
  - 内容检索工具
  - 主动引导工具
- **输出**：更新AgentState的tools_used

#### 1.4.4 观察节点 (observation_node)
- **功能**：ReAct的Observation阶段，获取工具执行结果
- **输出**：更新AgentState的messages（添加工具结果）

#### 1.4.5 判断节点 (should_continue)
- **功能**：判断是否需要继续推理
- **条件**：
  - 迭代次数 < 最大次数
  - 工具结果是否完整
  - 是否已得出最终答案
- **输出**：路由到reasoning_node或format_node

#### 1.4.6 输出格式化节点 (format_node)
- **功能**：格式化最终输出
- **特点**：
  - 回答不超过200字
  - 针对性强
  - 提供具体示例
- **输出**：更新AgentState的final_answer

## 二、智能体工作流程（LangGraph实现）

### 2.1 LangGraph状态图构建

```python
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver

# 创建状态图
graph = StateGraph(AgentState)

# 添加节点
graph.add_node("input", input_node)
graph.add_node("reasoning", reasoning_node)
graph.add_node("action", action_node)
graph.add_node("observation", observation_node)
graph.add_node("format", format_node)

# 添加边
graph.set_entry_point("input")
graph.add_edge("input", "reasoning")
graph.add_edge("reasoning", "action")
graph.add_edge("action", "observation")
graph.add_conditional_edges(
    "observation",
    should_continue,  # 判断函数
    {
        "continue": "reasoning",
        "end": "format"
    }
)
graph.add_edge("format", END)

# 编译图
app = graph.compile(checkpointer=MemorySaver())
```

### 2.2 用户提问流程（ReAct循环）

```python
async def handle_user_message(session_id, message, context):
    # 1. 初始化状态
    initial_state = AgentState(
        messages=[HumanMessage(content=message)],
        context=context,
        current_step=context.get("current_step"),
        current_question_id=context.get("current_question_id"),
        tools_used=[],
        reasoning=[],
        final_answer=None,
        iteration_count=0
    )
    
    # 2. 运行状态图（ReAct循环）
    config = {"configurable": {"thread_id": session_id}}
    final_state = await app.ainvoke(initial_state, config)
    
    # 3. 获取最终答案
    response = final_state["final_answer"]
    
    # 4. 保存对话（只保存用户和AI的交互，不保存内部调用）
    save_conversation(session_id, message, response)
    
    return response
```

### 2.3 ReAct循环示例

```python
# 迭代1
Thought: "用户问'什么是价值观？'，我需要解释这个概念。"
Action: search_knowledge(query="价值观", category="values")
Observation: "价值观是决定生活方式的重要因素..."
Thought: "我获得了定义，但还需要提供示例。"
Action: search_examples(category="values", limit=3)
Observation: "示例：发现、成长、自由..."
Thought: "信息已足够，可以生成回答。"
Action: generate_response(max_length=200)
Observation: "生成回答完成"
→ 判断：已完成，进入format节点

# 最终输出
"价值观是你认为重要的事，它决定了你的生活方式和工作目的。比如：发现新事物、追求成长、渴望自由等。"
```

### 2.2 主动引导流程

```python
def proactive_guidance(session_id, trigger, user_preference="normal"):
    # 触发条件
    triggers = {
        "idle_timeout": "用户X分钟无操作",
        "short_answer": "回答过短",
        "vague_answer": "回答模糊",
        "stuck": "卡在某个问题"
    }
    
    # 获取引导偏好
    preference = get_guide_preference(session_id)
    if preference == "quiet":
        timeout = GUIDE_QUIET_TIMEOUT  # 15分钟
    else:
        timeout = GUIDE_IDLE_TIMEOUT  # 10分钟
    
    # 获取上下文
    context = get_session_context(session_id)
    
    # 生成引导
    guidance = generate_guidance(trigger, context)
    
    # 提供示例
    examples = get_relevant_examples(context)
    
    # 获取默认引导问题
    guide_questions = get_default_guide_questions(
        current_step=context.current_step,
        category=context.current_category
    )
    
    # 保存引导记录
    save_guidance(session_id, guidance, examples)
    
    return {
        "guidance": guidance,
        "examples": examples,
        "suggestions": get_suggestions(context),
        "guide_questions": guide_questions  # 快速点选的引导问题
    }
```

## 三、工具定义（LangGraph Tools）

### 3.1 工具基类

```python
from langchain_core.tools import BaseTool
from typing import Optional

class BaseAgentTool(BaseTool):
    """智能体工具基类"""
    name: str
    description: str
    
    def _run(self, *args, **kwargs) -> str:
        """同步执行"""
        pass
    
    async def _arun(self, *args, **kwargs) -> str:
        """异步执行"""
        pass
```

### 3.2 工具列表

#### 3.2.1 概念解释工具
```python
class ConceptExplainTool(BaseAgentTool):
    name = "explain_concept"
    description = "解释概念的含义，结合用户上下文提供精炼回答"
    
    async def _arun(self, concept: str, context: Dict) -> str:
        # 检索概念定义
        # 生成解释
        # 返回精炼回答（<200字）
        pass
```

#### 3.2.2 问题引导工具
```python
class QuestionGuideTool(BaseAgentTool):
    name = "guide_question"
    description = "引导用户理解问题，提供思考方向"
    
    async def _arun(self, question_id: int, context: Dict) -> str:
        # 获取问题内容
        # 提供思考提示
        # 返回引导内容
        pass
```

#### 3.2.3 示例推荐工具
```python
class ExampleRecommendTool(BaseAgentTool):
    name = "recommend_examples"
    description = "推荐相关示例，帮助用户理解"
    
    async def _arun(self, topic: str, category: str, context: Dict) -> str:
        # 检索相关示例
        # 排序和筛选
        # 返回示例列表
        pass
```

#### 3.2.4 内容检索工具
```python
class ContentSearchTool(BaseAgentTool):
    name = "search_content"
    description = "从知识库检索相关内容"
    
    async def _arun(self, query: str, category: str, context: Dict) -> str:
        # 关键词/向量检索
        # 结果排序
        # 返回相关内容
        pass
```

#### 3.2.5 主动引导工具
```python
class ProactiveGuideTool(BaseAgentTool):
    name = "proactive_guide"
    description = "主动引导用户，提供帮助"
    
    async def _arun(self, trigger: str, context: Dict) -> str:
        # 根据触发条件生成引导
        # 提供默认引导问题
        # 返回引导内容
        pass
```

### 3.3 工具注册

```python
# 注册所有工具
tools = [
    ConceptExplainTool(),
    QuestionGuideTool(),
    ExampleRecommendTool(),
    ContentSearchTool(),
    ProactiveGuideTool()
]

# 绑定到LLM
llm_with_tools = llm.bind_tools(tools)
```

## 四、上下文管理

### 3.1 上下文管理接口

```python
class ContextManager:
    """上下文管理器 - 保留扩展接口"""
    
    def build_context(self, session_id: str, current_step: str) -> str:
        """
        构建上下文
        
        当前实现：直接拼接上下文全部内容
        未来可扩展：替换算法实现
        """
        # 获取用户信息
        user_info = self.get_user_info(session_id)
        
        # 获取工作履历（用于快速了解用户）
        work_history = self.get_work_history(session_id)
        
        # 获取当前步骤的已回答问题
        answered_questions = self.get_answered_questions(session_id, current_step)
        
        # 获取对话历史
        conversation_history = self.get_conversation_history(session_id, limit=10)
        
        # 当前实现：直接拼接
        context = f"""
用户信息：{user_info}
工作履历：{work_history}
已回答问题：{answered_questions}
对话历史：{conversation_history}
当前步骤：{current_step}
"""
        return context
    
    def get_user_info(self, session_id: str) -> str:
        """获取用户基本信息"""
        # 从数据库获取用户信息
        pass
    
    def get_work_history(self, session_id: str) -> str:
        """获取工作履历（用于快速了解用户能力、价值观）"""
        # 从数据库获取工作履历
        pass
    
    def get_answered_questions(self, session_id: str, step: str) -> str:
        """获取已回答的问题"""
        # 从数据库获取已回答问题
        pass
    
    def get_conversation_history(self, session_id: str, limit: int = 10) -> str:
        """获取对话历史"""
        # 从数据库获取对话历史
        pass
```

### 3.2 上下文扩展点

**保留方法接口，便于后期优化**：
- `build_context()`: 上下文构建方法（可替换算法）
- `compress_context()`: 上下文压缩方法（未来添加）
- `summarize_context()`: 上下文摘要方法（未来添加）
- `filter_context()`: 上下文过滤方法（未来添加）

## 五、LLM提示词设计

### 4.1 系统提示词模板

```
你是一个专业的职业规划助手，帮助用户找到"真正想做的事"。

核心公式：
- 公式1：喜欢的事 × 擅长的事 = 想做的事
- 公式2：喜欢的事 × 擅长的事 × 重要的事 = 真正想做的事

你的任务：
1. 回答用户关于概念、问题、方法的疑问
2. 提供精炼、针对性的回答（不超过200字）
3. 结合用户当前进度和上下文
4. 提供具体示例，避免抽象说教
5. 引导用户深入思考，但不过度干预

当前用户状态：
- 当前步骤：{current_step}
- 当前问题：{current_question}
- 已完成问题数：{completed_count}/{total_count}

回答要求：
- 精炼：不超过200字
- 针对性：结合用户具体问题
- 示例：提供1-2个具体示例
- 引导性：适当引导下一步思考
```

### 4.2 不同场景的提示词

#### 场景1：概念解释
```
用户询问：{concept}

请用简洁的语言（不超过150字）解释这个概念，并：
1. 说明它在"找到想做的事"中的作用
2. 提供1个具体示例
3. 如果相关，说明它与公式的关系
```

#### 场景2：问题引导
```
用户对问题感到困惑：{question}

用户当前回答：{user_answer}（如果有）

请：
1. 用简单的方式重新解释这个问题（不超过100字）
2. 提供1-2个回答示例
3. 给出思考方向提示
```

#### 场景3：示例推荐
```
用户需要示例，主题：{topic}
用户当前步骤：{current_step}

从知识库中检索相关内容，然后：
1. 推荐2-3个最相关的示例
2. 简要说明为什么这些示例相关
3. 引导用户思考自己的情况
```

#### 场景4：主动引导
```
用户状态：{trigger}
- 如果idle_timeout：用户X分钟无操作
- 如果short_answer：回答过短
- 如果vague_answer：回答模糊
- 如果stuck：卡在某个问题

请：
1. 友好地提醒用户继续
2. 提供思考提示
3. 推荐相关示例
4. 不超过150字
```

## 六、知识库检索策略

### 4.1 关键词匹配（初期）

```python
def keyword_search(query, category="all"):
    # 1. 分词
    keywords = tokenize(query)
    
    # 2. 从CSV文件搜索
    results = []
    if category in ["all", "values"]:
        results.extend(search_csv("重要的事_价值观.csv", keywords))
    if category in ["all", "strengths"]:
        results.extend(search_csv("擅长的事_才能.csv", keywords))
    if category in ["all", "interests"]:
        results.extend(search_csv("喜欢的事_热情.csv", keywords))
    
    # 3. 从question.md搜索
    results.extend(search_questions(keywords))
    
    # 4. 排序和过滤
    results = rank_results(results, keywords)
    
    return results[:10]  # 返回前10个
```

### 4.2 语义检索（可选，P2）

```python
def semantic_search(query, category="all"):
    # 1. 生成查询向量
    query_embedding = get_embedding(query)
    
    # 2. 向量相似度搜索
    results = vector_db.search(
        query_embedding,
        category=category,
        limit=10
    )
    
    return results
```

## 七、主动引导策略

### 5.1 触发条件（可配置）

| 触发条件 | 检测方法 | 引导内容 | 配置项 |
|---------|---------|---------|--------|
| 空闲超时 | 最后活动时间 > 配置值 | 提醒继续，提供当前问题提示 | `GUIDE_IDLE_TIMEOUT` (默认600秒/10分钟) |
| 安静模式 | 用户要求安静 | 延长到15分钟 | `GUIDE_QUIET_TIMEOUT` (默认900秒/15分钟) |
| 回答过短 | 回答字数 < 阈值 | 引导深入思考，提供示例 | `GUIDE_SHORT_ANSWER_THRESHOLD` (默认20字) |
| 回答模糊 | 关键词匹配判断 | 引导具体化，提供思考方向 | 自动检测 |
| 卡在问题 | 同一问题停留 > 阈值 | 重新解释问题，提供示例 | `GUIDE_STUCK_TIMEOUT` (默认600秒) |

### 5.2 引导策略配置

```python
# config/guide_config.py
GUIDE_STRATEGIES = {
    "idle_timeout": {
        "enabled": True,
        "timeout": 600,  # 10分钟（秒）
        "quiet_timeout": 900,  # 15分钟（用户要求安静时）
        "action": "proactive_guide"
    },
    "short_answer": {
        "enabled": True,
        "threshold": 20,  # 字数阈值
        "action": "passive_guide"
    },
    "vague_answer": {
        "enabled": True,
        "action": "passive_guide"
    },
    "stuck": {
        "enabled": True,
        "timeout": 600,  # 10分钟
        "action": "passive_guide"
    }
}
```

### 5.3 默认引导问题

```python
# 不同步骤和类别的默认引导问题
DEFAULT_GUIDE_QUESTIONS = {
    "values_exploration": [
        {"id": "guide_1", "text": "这个问题是什么意思？", "type": "concept_query"},
        {"id": "guide_2", "text": "能给我一个示例吗？", "type": "example_request"},
        {"id": "guide_3", "text": "我不太确定怎么回答", "type": "confusion"},
        {"id": "guide_4", "text": "这个问题和我的工作有什么关系？", "type": "relevance"}
    ],
    "strengths_exploration": [
        {"id": "guide_1", "text": "什么是擅长的事？", "type": "concept_query"},
        {"id": "guide_2", "text": "能给我一个示例吗？", "type": "example_request"},
        {"id": "guide_3", "text": "我不太确定怎么回答", "type": "confusion"}
    ],
    "interests_exploration": [
        {"id": "guide_1", "text": "什么是喜欢的事？", "type": "concept_query"},
        {"id": "guide_2", "text": "能给我一个示例吗？", "type": "example_request"},
        {"id": "guide_3", "text": "我不太确定怎么回答", "type": "confusion"}
    ]
}
```

### 5.4 引导内容生成

```python
def generate_guidance(trigger, context):
    # 从配置读取策略
    strategy = GUIDE_STRATEGIES.get(trigger, {})
    if not strategy.get("enabled", False):
        return None
    
    templates = {
        "idle_timeout": "你已经{minutes}分钟没有操作了。当前你在回答第{question_number}个问题：{question_title}。需要我帮你理解这个问题吗？",
        "short_answer": "你的回答比较简短。这个问题可能需要更深入的思考。比如：{example}。你可以尝试从这些角度思考。",
        "vague_answer": "你的回答可能还不够具体。试着问自己：{thinking_questions}。",
        "stuck": "看起来你可能对这个问题有些困惑。让我换个方式解释：{rephrased_question}。或者你可以参考这个示例：{example}。"
    }
    
    template = templates.get(trigger, "继续思考...")
    return format_template(template, context)
```

## 八、回答质量保证

### 6.1 回答验证

```python
def validate_response(response):
    checks = {
        "length": len(response) <= 200,
        "has_example": "示例" in response or "比如" in response,
        "not_too_abstract": not is_too_abstract(response),
        "relevant": is_relevant(response, context)
    }
    
    if not all(checks.values()):
        # 重新生成
        return regenerate_response(response, checks)
    
    return response
```

### 6.2 回答优化

- **过长**：自动总结
- **过短**：补充示例
- **太抽象**：添加具体说明
- **不相关**：重新生成

## 九、性能优化

### 7.1 缓存策略
- **常见问题回答**：缓存1小时
- **概念解释**：缓存24小时
- **示例推荐**：缓存10分钟

### 7.2 异步处理
- **LLM调用**：异步处理
- **知识库检索**：并行查询
- **响应生成**：流式输出（可选）

## 十、错误处理

### 10.1 LangGraph错误处理
- **节点错误**：捕获异常，返回错误信息到状态
- **工具错误**：降级处理，使用备用方法
- **循环保护**：最大迭代次数限制，防止无限循环

### 10.2 ReAct循环控制
- **最大迭代次数**：默认5次
- **超时控制**：单次循环超时30秒
- **提前终止**：检测到最终答案时提前结束

### 8.1 LLM调用失败
- **降级策略**：使用预定义回答
- **重试机制**：最多重试3次
- **用户提示**：友好错误提示

### 8.2 知识库检索失败
- **降级策略**：使用关键词匹配
- **备用数据**：使用内存缓存
