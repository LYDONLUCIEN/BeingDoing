# 架构切换与模块接口设计

## 一、架构模式

### 1.1 简化架构（Simple Architecture）

**适用场景**：验证阶段、低并发（2-5用户）、快速开发

**特点**：
- 无外部依赖（Nginx、Chroma、Redis、Celery）
- 内存存储和缓存
- SQLite数据库
- FastAPI内置静态文件服务
- 内存向量存储
- 内存任务队列

**优势**：
- 部署简单，单容器即可运行
- 无需配置外部服务
- 适合快速验证和开发

### 1.2 完整架构（Full Architecture）

**适用场景**：生产环境、高并发、大规模数据

**特点**：
- 使用Nginx网关和负载均衡
- Chroma/FAISS向量数据库
- Redis缓存
- Celery任务队列
- PostgreSQL数据库
- 独立的静态文件服务

**优势**：
- 高性能
- 可扩展
- 适合生产环境

## 二、架构切换机制

### 2.1 全局配置

```python
# config/architecture.py
ARCHITECTURE_MODE = os.getenv("ARCHITECTURE_MODE", "simple")  # simple | full

# 架构配置字典
ARCH_CONFIG = {
    "simple": {
        "use_gateway": False,
        "use_vector_db": False,
        "use_redis": False,
        "use_celery": False,
        "static_files": "fastapi",
        "vector_store": "memory",
        "cache": "memory",
        "database": "sqlite",
        "task_queue": "memory"
    },
    "full": {
        "use_gateway": True,
        "use_vector_db": True,
        "use_redis": True,
        "use_celery": True,
        "static_files": "nginx",
        "vector_store": "chroma",
        "cache": "redis",
        "database": "postgresql",
        "task_queue": "celery"
    }
}

def get_arch_config():
    """获取当前架构配置"""
    return ARCH_CONFIG.get(ARCHITECTURE_MODE, ARCH_CONFIG["simple"])

def is_simple_mode():
    """判断是否为简化架构"""
    return ARCHITECTURE_MODE == "simple"
```

### 2.2 模块接口设计原则

**原则**：
1. **统一接口**：所有模块提供统一接口
2. **实现分离**：简单实现和完整实现分离
3. **自动切换**：根据架构模式自动选择实现
4. **保留扩展**：保留接口和思路，便于后续扩展

## 三、核心模块接口设计

### 3.1 LLM接入模块接口

```python
# src/backend/app/core/llmapi/api.py
from abc import ABC, abstractmethod
from typing import List, AsyncIterator
from langchain_core.messages import BaseMessage

class LLMAPIBase(ABC):
    """LLM API基类"""
    
    @abstractmethod
    async def chat(self, messages: List[BaseMessage], **kwargs) -> str:
        """聊天接口"""
        pass
    
    @abstractmethod
    async def stream_chat(self, messages: List[BaseMessage], **kwargs) -> AsyncIterator[str]:
        """流式聊天接口"""
        pass

class LLMAPI:
    """LLM API统一接口"""
    
    def __init__(self, provider: str = "openai"):
        self.provider = provider
        self._impl = self._get_implementation()
    
    def _get_implementation(self) -> LLMAPIBase:
        """根据配置选择实现"""
        if self.provider == "openai":
            from .providers.openai import OpenAILLM
            return OpenAILLM()
        elif self.provider == "local":
            from .providers.local import LocalLLM
            return LocalLLM()
        else:
            raise ValueError(f"Unknown provider: {self.provider}")
    
    async def chat(self, messages: List[BaseMessage], **kwargs) -> str:
        return await self._impl.chat(messages, **kwargs)
    
    async def stream_chat(self, messages: List[BaseMessage], **kwargs) -> AsyncIterator[str]:
        async for chunk in self._impl.stream_chat(messages, **kwargs):
            yield chunk
```

### 3.2 ASR接入模块接口

```python
# src/backend/app/core/asr/api.py
from abc import ABC, abstractmethod
from typing import Optional

class ASRAPIBase(ABC):
    """ASR API基类"""
    
    @abstractmethod
    async def transcribe(self, audio: bytes, language: str = "zh") -> str:
        """转录音频为文字"""
        pass
    
    @abstractmethod
    async def transcribe_file(self, file_path: str, language: str = "zh") -> str:
        """转录音频文件为文字"""
        pass

class ASRAPI:
    """ASR API统一接口"""
    
    def __init__(self, provider: str = "openai"):
        self.provider = provider
        self._impl = self._get_implementation()
    
    def _get_implementation(self) -> ASRAPIBase:
        """根据配置选择实现"""
        if self.provider == "openai":
            from .providers.openai_whisper import OpenAIWhisper
            return OpenAIWhisper()
        elif self.provider == "local":
            from .providers.local_whisper import LocalWhisper
            return LocalWhisper()
        elif self.provider == "web_speech":
            from .providers.web_speech import WebSpeechAPI
            return WebSpeechAPI()
        else:
            raise ValueError(f"Unknown provider: {self.provider}")
    
    async def transcribe(self, audio: bytes, language: str = "zh") -> str:
        return await self._impl.transcribe(audio, language)
    
    async def transcribe_file(self, file_path: str, language: str = "zh") -> str:
        return await self._impl.transcribe_file(file_path, language)
```

### 3.3 TTS接入模块接口

```python
# src/backend/app/core/tts/api.py
from abc import ABC, abstractmethod
from typing import Optional

class TTSAPIBase(ABC):
    """TTS API基类"""
    
    @abstractmethod
    async def synthesize(self, text: str, voice: str = "alloy") -> bytes:
        """合成语音"""
        pass
    
    @abstractmethod
    async def synthesize_to_file(self, text: str, output_path: str, voice: str = "alloy") -> str:
        """合成语音到文件"""
        pass

class TTSAPI:
    """TTS API统一接口"""
    
    def __init__(self, provider: str = "openai"):
        self.provider = provider
        self._impl = self._get_implementation()
    
    def _get_implementation(self) -> TTSAPIBase:
        """根据配置选择实现"""
        if self.provider == "openai":
            from .providers.openai_tts import OpenAITTS
            return OpenAITTS()
        elif self.provider == "pyttsx3":
            from .providers.pyttsx3 import Pyttsx3TTS
            return Pyttsx3TTS()
        elif self.provider == "gtts":
            from .providers.gtts import GoogleTTS
            return GoogleTTS()
        else:
            raise ValueError(f"Unknown provider: {self.provider}")
    
    async def synthesize(self, text: str, voice: str = "alloy") -> bytes:
        return await self._impl.synthesize(text, voice)
    
    async def synthesize_to_file(self, text: str, output_path: str, voice: str = "alloy") -> str:
        return await self._impl.synthesize_to_file(text, output_path, voice)
```

### 3.4 向量存储接口

```python
# src/backend/app/core/knowledge/vector/base.py
from abc import ABC, abstractmethod
from typing import List, Dict, Optional

class VectorStoreBase(ABC):
    """向量存储基类"""
    
    @abstractmethod
    async def add_vectors(self, vectors: List[List[float]], texts: List[str], metadatas: List[Dict]) -> List[str]:
        """添加向量"""
        pass
    
    @abstractmethod
    async def search(self, query_vector: List[float], top_k: int = 10) -> List[Dict]:
        """搜索相似向量"""
        pass
    
    @abstractmethod
    async def delete(self, ids: List[str]) -> bool:
        """删除向量"""
        pass

# src/backend/app/core/knowledge/vector/memory.py
class MemoryVectorStore(VectorStoreBase):
    """内存向量存储（简化架构）"""
    
    def __init__(self):
        self._store: Dict[str, Dict] = {}
    
    async def add_vectors(self, vectors: List[List[float]], texts: List[str], metadatas: List[Dict]) -> List[str]:
        # 内存存储实现
        pass
    
    async def search(self, query_vector: List[float], top_k: int = 10) -> List[Dict]:
        # 内存搜索实现（使用余弦相似度）
        pass

# src/backend/app/core/knowledge/vector/chroma.py
class ChromaVectorStore(VectorStoreBase):
    """Chroma向量存储（完整架构）"""
    
    def __init__(self, persist_dir: Optional[str] = None):
        import chromadb
        self.client = chromadb.Client()
        # 初始化Chroma
        pass
    
    async def add_vectors(self, vectors: List[List[float]], texts: List[str], metadatas: List[Dict]) -> List[str]:
        # Chroma实现
        pass
    
    async def search(self, query_vector: List[float], top_k: int = 10) -> List[Dict]:
        # Chroma搜索实现
        pass

# src/backend/app/core/knowledge/vector/__init__.py
def get_vector_store():
    """根据架构模式获取向量存储"""
    from app.config.architecture import get_arch_config
    
    config = get_arch_config()
    vector_store_type = config.get("vector_store", "memory")
    
    if vector_store_type == "memory":
        from .memory import MemoryVectorStore
        return MemoryVectorStore()
    elif vector_store_type == "chroma":
        from .chroma import ChromaVectorStore
        return ChromaVectorStore()
    elif vector_store_type == "faiss":
        from .faiss import FAISSVectorStore
        return FAISSVectorStore()
    else:
        raise ValueError(f"Unknown vector store: {vector_store_type}")
```

### 3.5 缓存接口

```python
# src/backend/app/core/cache/base.py
from abc import ABC, abstractmethod
from typing import Optional, Any

class CacheBase(ABC):
    """缓存基类"""
    
    @abstractmethod
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        pass
    
    @abstractmethod
    async def set(self, key: str, value: Any, ttl: int = 3600) -> bool:
        """设置缓存"""
        pass
    
    @abstractmethod
    async def delete(self, key: str) -> bool:
        """删除缓存"""
        pass

# src/backend/app/core/cache/memory.py
class MemoryCache(CacheBase):
    """内存缓存（简化架构）"""
    
    def __init__(self):
        self._cache: Dict[str, Tuple[Any, float]] = {}
    
    async def get(self, key: str) -> Optional[Any]:
        # 内存缓存实现
        pass
    
    async def set(self, key: str, value: Any, ttl: int = 3600) -> bool:
        # 内存缓存实现
        pass

# src/backend/app/core/cache/redis.py
class RedisCache(CacheBase):
    """Redis缓存（完整架构）"""
    
    def __init__(self, redis_url: str):
        import redis
        self.client = redis.from_url(redis_url)
    
    async def get(self, key: str) -> Optional[Any]:
        # Redis实现
        pass
    
    async def set(self, key: str, value: Any, ttl: int = 3600) -> bool:
        # Redis实现
        pass

# src/backend/app/core/cache/__init__.py
def get_cache():
    """根据架构模式获取缓存"""
    from app.config.architecture import get_arch_config
    
    config = get_arch_config()
    cache_type = config.get("cache", "memory")
    
    if cache_type == "memory":
        from .memory import MemoryCache
        return MemoryCache()
    elif cache_type == "redis":
        from .redis import RedisCache
        redis_url = os.getenv("REDIS_URL", "redis://localhost:6379")
        return RedisCache(redis_url)
    else:
        raise ValueError(f"Unknown cache: {cache_type}")
```

### 3.6 任务队列接口

```python
# src/backend/app/core/async_service/base.py
from abc import ABC, abstractmethod
from typing import Callable, Any

class TaskQueueBase(ABC):
    """任务队列基类"""
    
    @abstractmethod
    async def enqueue(self, task_name: str, *args, **kwargs) -> str:
        """入队任务"""
        pass
    
    @abstractmethod
    async def get_result(self, task_id: str) -> Any:
        """获取任务结果"""
        pass

# src/backend/app/core/async_service/simple_queue.py
class SimpleMemoryQueue(TaskQueueBase):
    """简单内存队列（简化架构）"""
    
    def __init__(self):
        self._queue: List[Dict] = []
        self._results: Dict[str, Any] = {}
    
    async def enqueue(self, task_name: str, *args, **kwargs) -> str:
        # 内存队列实现
        # 同步执行或简单异步执行
        pass
    
    async def get_result(self, task_id: str) -> Any:
        # 获取结果
        pass

# src/backend/app/core/async_service/celery_queue.py
class CeleryQueue(TaskQueueBase):
    """Celery队列（完整架构）"""
    
    def __init__(self, broker_url: str):
        from celery import Celery
        self.app = Celery('tasks', broker=broker_url)
    
    async def enqueue(self, task_name: str, *args, **kwargs) -> str:
        # Celery实现
        pass
    
    async def get_result(self, task_id: str) -> Any:
        # Celery结果获取
        pass

# src/backend/app/core/async_service/__init__.py
def get_task_queue():
    """根据架构模式获取任务队列"""
    from app.config.architecture import get_arch_config
    
    config = get_arch_config()
    queue_type = config.get("task_queue", "memory")
    
    if queue_type == "memory":
        from .simple_queue import SimpleMemoryQueue
        return SimpleMemoryQueue()
    elif queue_type == "celery":
        from .celery_queue import CeleryQueue
        broker_url = os.getenv("CELERY_BROKER_URL", "redis://localhost:6379/0")
        return CeleryQueue(broker_url)
    else:
        raise ValueError(f"Unknown task queue: {queue_type}")
```

### 3.7 数据库连接接口

```python
# src/backend/app/core/database/connection.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

def get_database_url():
    """根据架构模式获取数据库URL"""
    from app.config.architecture import get_arch_config
    
    config = get_arch_config()
    db_type = config.get("database", "sqlite")
    
    if db_type == "sqlite":
        return "sqlite+aiosqlite:///./app.db"
    elif db_type == "postgresql":
        return os.getenv("DATABASE_URL", "postgresql+asyncpg://user:pass@localhost/db")
    else:
        raise ValueError(f"Unknown database: {db_type}")

# 创建数据库引擎
engine = create_async_engine(get_database_url())

# 创建会话工厂
AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)
```

### 3.8 静态文件服务接口

```python
# src/backend/app/core/static/base.py
from abc import ABC, abstractmethod
from fastapi import FastAPI

class StaticFilesBase(ABC):
    """静态文件服务基类"""
    
    @abstractmethod
    def mount(self, app: FastAPI):
        """挂载静态文件服务"""
        pass

# src/backend/app/core/static/fastapi_static.py
class FastAPIStaticFiles(StaticFilesBase):
    """FastAPI内置静态文件服务（简化架构）"""
    
    def mount(self, app: FastAPI):
        from fastapi.staticfiles import StaticFiles
        app.mount("/static", StaticFiles(directory="src/frontend/dist"), name="static")

# src/backend/app/core/static/nginx_static.py
class NginxStaticFiles(StaticFilesBase):
    """Nginx静态文件服务（完整架构）"""
    
    def mount(self, app: FastAPI):
        # 不挂载，由Nginx处理
        pass

# src/backend/app/core/static/__init__.py
def get_static_files():
    """根据架构模式获取静态文件服务"""
    from app.config.architecture import get_arch_config
    
    config = get_arch_config()
    static_type = config.get("static_files", "fastapi")
    
    if static_type == "fastapi":
        from .fastapi_static import FastAPIStaticFiles
        return FastAPIStaticFiles()
    elif static_type == "nginx":
        from .nginx_static import NginxStaticFiles
        return NginxStaticFiles()
    else:
        raise ValueError(f"Unknown static files: {static_type}")
```

## 四、使用示例

### 4.1 模块使用示例

```python
# 使用LLM API（自动选择实现）
from app.core.llmapi import LLMAPI

llm = LLMAPI(provider="openai")
response = await llm.chat(messages)

# 使用ASR API（自动选择实现）
from app.core.asr import ASRAPI

asr = ASRAPI(provider="openai")
text = await asr.transcribe(audio_bytes)

# 使用向量存储（根据架构自动选择）
from app.core.knowledge.vector import get_vector_store

vector_store = get_vector_store()
results = await vector_store.search(query_vector, top_k=10)

# 使用缓存（根据架构自动选择）
from app.core.cache import get_cache

cache = get_cache()
value = await cache.get("key")
await cache.set("key", "value", ttl=3600)

# 使用任务队列（根据架构自动选择）
from app.core.async_service import get_task_queue

queue = get_task_queue()
task_id = await queue.enqueue("export_pdf", session_id="...")
result = await queue.get_result(task_id)
```

### 4.2 架构切换示例

```python
# 简化架构启动
export ARCHITECTURE_MODE=simple
export DATABASE_URL=sqlite:///./app.db
uvicorn app.main:app --reload

# 完整架构启动
export ARCHITECTURE_MODE=full
export DATABASE_URL=postgresql://user:pass@localhost/db
export REDIS_URL=redis://localhost:6379
export CHROMA_URL=http://localhost:8000
uvicorn app.main:app --reload
```

## 五、扩展接口保留

### 5.1 网关接口（保留，暂不实现）

```python
# src/backend/app/core/gateway/base.py
class GatewayBase(ABC):
    """网关基类（保留接口）"""
    
    @abstractmethod
    def setup(self):
        """设置网关"""
        pass

# 当前：不实现，直接使用FastAPI
# 未来：可以实现Nginx配置生成等
```

### 5.2 向量数据库接口（保留，暂不实现）

```python
# 当前：使用内存向量存储
# 未来：可以切换到Chroma/FAISS
# 接口已定义，只需切换实现
```

### 5.3 其他扩展接口

- **监控接口**：保留监控和日志接口
- **分析接口**：保留数据分析接口
- **扩展点**：所有模块保留扩展点

## 六、目录结构补充

```
src/backend/app/core/
├── gateway/              # 网关模块（保留接口，暂不实现）
│   ├── __init__.py
│   ├── base.py
│   └── nginx.py          # 未来实现
├── cache/                # 缓存模块
│   ├── __init__.py
│   ├── base.py
│   ├── memory.py         # 内存缓存（简化架构）
│   └── redis.py          # Redis缓存（完整架构）
└── static/               # 静态文件服务
    ├── __init__.py
    ├── base.py
    ├── fastapi_static.py # FastAPI内置（简化架构）
    └── nginx_static.py   # Nginx服务（完整架构）
```
